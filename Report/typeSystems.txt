TYPE SYSTEM
[21] https://en.wikipedia.org/wiki/Type_system

TYPE THEORY
[22] https://en.wikipedia.org/wiki/Type_theory#Basic_concepts


This section introduces the basic steps in the designing of a programming language and focuses on the theory of Type Systems. Figure _ displays the step-by-step breakdown of the design process of Mini-EnsembleS programs. The Mini-EnsembleS program source code is fed into the pipeline; the first stage is the parser, which translates the input code into an Abstract Syntax Tree, followed by the type checker and the runtime systems to execute this intermediate output.

FIGURE

Parser
The first step in designing most programming languages is lexing, or tokenizing, which splits the input text into tokens. The lexer ideally takes a string/strings containing the program source code and outputs a list containing every token.
The parser's task is to turn a list of tokens into a tree of nodes adding structure to it. It takes the text of our programs and interprets which commands the code expresses. It recognizes statements, expressions and creates internal data structures to represent them - an Abstract Syntax Tree or AST. AST provides a method to represent the input code as a higher-level data structure, eliminating information that is not crucial for processing the commands in the following stages. These next stages in the pipeline will not refer back to the original source code, so the parser must extract all the required information. The reason for this relatively strict pipeline format is that the parser may do tasks such as removing comments or detecting if a token is a string or an integer. It is beneficial to encapsulate this logic inside the parser at the initial stages of the pipeline so as to not worry about these rules at further stages as well as the flexibility this provides to change the syntax at this base level itself.
For our implementation, we combine the stages of lexing and parsing together for simplicity.

Parsing the source code gives an intermediate representation of the program in the form of an Abstract Syntax Tree. Languages can be ambiguous often, and ASTs are needed because of the inherent nature of these programming languages. ASTs can be manipulated and contain concise information allowing to raise informative error messages. A complete traversal of the generated AST allows verification of the correctness of the program, which is the task of our type system. After verifying correctness, the AST serves as the base for runtime systems and code generation.

Type System
The purpose of a type system is to reduce the bugs in computer systems [11], by creating interfaces between different segments and then checking that these components are connected meaningfully. A type system is a logical framework that associates a type to different structures of a program, such as variables, expressions and functions and, by examining the exchange of these values, prevents type errors from occurring. Type checking can be done statically (at compile time), dynamically (at run time), or both ways [21]. Static type checking is the technique of determining a program's type safety based on text analysis (source code)[21]. A program that passes a static type checker is guaranteed to meet a set of type safety characteristics for all potential inputs. The method of confirming the type safety of a program at runtime is known as dynamic type checking. Each runtime object is usually associated with a type tag (i.e., a reference to a type) carrying its type information in dynamically type-checked languages. This information can be used to implement the type-checking features.


In a system of type theory, a term is contrasted to a type in a type theory system. For example, 1, 2+3, 4 * 5 are all separate terms each of type int for integers; true, false are terms of type bool. The letter e is used to denote terms, whereas the letter $\tau$ is used to denote types. The expression term : 'type' indicates that the term is of the type 'type'. "hello world" : string indicates that "hello world" is of the type string.

A typical judgment has the form: $\Gamme \vdash \xi$, where $\xi$ is an assertion and \Gamma is a static typing environment under which typing takes place[11]. Often, an environment is a list of pairs e:\tau, distinct variables, and their types. The empty environment is denoted by $\phi$ , and the collection of variables x_1 ... x_n declared in $\Gamma$ is indicated by dom($\Gamma$), the domain of $\Gamma$.
A type judgment is of the form $\Gamme \vdash M:A$, which asserts that a term M has a type A under the typing environment $\Gamma$. For example, 
	$\phi \vdash true : Bool$, which implies, true is of type Bool
	$\phi, x:Nat \vdash x+1 : Nat$, which implies, type of x+1 is Nat if x is of type Nat

Other judgment forms including these are essential as a whole to validate a type system; a popular one asserts simply that an environment is well-formed, properly constructed [11]:
	$\Gamma \vdash \diamond$
Any given judgment can be valid (e.g., Γ 1 : Nat) or invalid (e.g., Γ true : Nat). Validity formalizes the notion of well-typed programs.
Type rules assert the validity of certain judgments based on other judgments that are already known to be valid [11]. 
EQUATION
\frac{\Gamma_1 \vdash \xi_1  ...  \Gamma_n \vdash \xi_n}{\Gamma \vdash \xi}
Each type rule is stated as a series of premise judgments $\Gamma _i \vdash \xi_i$ above a horizontal line, followed by a single conclusion judgment $\Gamma \vdash \xi$. The conclusion must hold when all of the premises are satisfied. The number of premise judgments may be zero as well. A type system is a set of type rules.