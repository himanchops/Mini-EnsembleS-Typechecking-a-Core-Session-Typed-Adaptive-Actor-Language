CALCULUS
This section introduces the syntax and semantics of the formal calculus of EnsembleS [2]. This is the core conceptualization of EnsembleS that allows for adaptation, while preventing the inherent communication mismatches owing to characteristics of Ensemble using the theory of Multiparty sesion Types. The project aims at implementing a type checker for this calculus and the typing rules discussed are the most crucial part of focus thus.

With explicit connection actions, the core calculus tries to distil the essence of the interplay between adaptation and session-typed communication. The choice of a functional core calculus over an imperative calculus is to avoid dealing with imperative variable bindings that scatter and clutter the formalism. Also, type safety, the support for algebraic data types and mathematical purity in this declarative programming enables us to focus on the formalism rather than the implementation details as in case of Java based applications like Ensemble. Since dynamic topologies with explicit connection actions are more crucial for adaptation, the calculus focuses on these rather than static topologies.


SYNTAX
Table shows the syntax of types and terms in the calculus of EnsembleS [2].

Definitions:
Actor class names are defined using u whereas D ranges over actor definitions. Each definition follows the syntax - actor u follows S {M}. This definition specifies the actor's aclass name, session type and the behaviour it follows. For a provided actor definition - actor u follows S {M}, we define sessionType(u) = S and behaviour(u) = M.

Values:
The calculus works in the setting of fine-grain call-by-value, where there is an explicit classification of values and computations and an explicit order of evaluation [2]. Values V,W describe data that has been computed. A value v can be a variable x or unit value defined by () or one of the base values. Base values consists of string for strings, int for integers, and bool(true / false) for booleans.


Computations:
The statement let x <= M in N first evaluates the computation M, binds its result to x and continues to the computation N with x. As syntactic sugar, for a fresh variable x, we can write let x <= M in N as M;N. 
The calculus supports exception handling over a single action L using try L catch M construct; L action is evaluated and if it raises an exception, M is evaluated. l :: M syntax is for labelled recursion, stating that inside the computation term M, a process can recurse to label l using the syntax continue l. Actions L consist of all the basic steps of a computation. The statement M;N denotes a sequence of computations; evaluation of term M followed by evaluation of N. The return V construct returns a value.

Concurrency and adaptation constructs :
The construct new u spawns a new actor u and returns the PID of its session type. Similarly, the syntax self returns the current actor's PID. Using the construct replace V with k, an actor can replace the behaviour of an actor V, including itself with another behaviour k. The construct discover S, returns the PID of the discovered actor. This can be used by an actor to discover other actors following a session type S. 


Session communication constructs.
An actor can communicate with other actors using the following constructs: 
Syntax connect l(V) to W as p enables an actor to connect to an actor W playing a role p, sending a message with label l and a payload V.
Similarly, an incoming connection can be accepted by an actor using the construct accept from p {li(xi) -> Mi}i. This denotes accepting a connection from an actor playing role p along with a choice of messages. Each message consists of a label lj along with associated payload which is bound to xj in the followed computation Mj. As syntactic sugar, we can accept a connection with a single message as accept l(x) from p; M for simplicity.
Once a connection has been made, an actor can communicate using the send and receive constructs. send l(V) to p sends a message consisting of label l and payload V to an actor playing role p. Similarly, an actor can receive a choice of messages from an actor playing role p using receive from p {li(xi) -> Mi}i. We can also use the syntactic sugar receive l(x) from p; M to receive a singleton message.
An actor can disconnect from a role p using disconnect from p and await the disconnection of p using the construct wait p.


Types.
Types are denoted and ranged over by A,B. These include the unit type, base types such as String, Int, Bool as well as process IDs Pid(S); S here refers to the staticatlly-known initially defined session type of an actor, which can be found in the follows clause of the actor's definition. Process IDs do not have to be linear, as they do in channel-based session-typed systems; any number of actors can refer to another actor, but each actor can only be in one session at a time. Thus, unit type, base types and process IDs can be passed as payloads in session communications.


Session Actions and Session Types
Session Actions, ranged over by $\alpha, \beta$, involve the session communication actions of an actor with a participant p and message with label l and type A. A session action can be one of the following; sending - p ! l(A), receiving - p ? l(A), connecting - p !! l(A), accepting - p ?? l(A) or awaiting another participant's disconnection # p.
Session types, ranged over by S,T,U, can be one of the following: a choice of action - \sum_{i \in I}(\alpha_i . S), a recursive session type \mu X.S binding recursion variable X in continuation session type S, a recursion variable X (appearing inside the recursive session type S), a disconnection action ##p, as an identifier. To allow output-directed options to send or connect to multiple roles, the syntax of session types is more open than standard 'directed' presentations [2]. We also require the
following syntactic restrictions on session types [10]:



Definition 1 (Syntactic validity).
An action choice type $S = \sum_{i \in I} (\alpha_i . S_i)$ is syntactically valid if:
1. it is an output choice, i.e., each \alpha_i is either a send (p ! l(A)) or a connect (p !! l(A)) action  ; or
2. it is a directed input choice, i.e., receive $S = \sum_{i \in I} (p ? l_i(A_i) . S_i) or accept S = \sum_{i \in I} (p ?? l_i(A_i) . S_i)$; or
3. the choice consists of single wait action #p . S.
We assume that all session types are syntactically valid for the following report.


Session correlation.
The most general form of explicit connection actions allows a participant to leave and re-join a session, or accept connections from multiple different participants. Such broadness comes at a cost, since it is necessary to ensure that the same participant plays the same role throughout the session.
Two solutions are proposed by Hu & Yoshida [10] to address this problem. First, to augment global types with type-level assertions and check conformance dynamically; Second approach is to adopt a lightweight syntactic restriction that restricts each local type to have a single accept action as its top-level construct. EnsembleS follows the second approach, imposing the requirement as part of our safety property of Preservation and ensuring that a participant's disconnection (##p) has no continuation. The behaviour of actors repeat again after disconnecting and hence, a participant will be able to accept again after disconnecting and followed termination. This approach still covers the most typical use cases of explicit connection activities, as Hu & Yoshida [10] demonstrate.

Global Types
In traditional MPST theory, global types are used to describe the message exchanges between pairs of participants from the global perspective, which are then projected into local types. This projectability ensures safety and deadlock freedom.

Traditional MPST approaches allow for an excessive flexibility in its calculus as they do not account for certain roles being present in certain branches but not others. Since our calculus entails explicit connection actions, we formulate our typing rules and safety properties using collections of local types instead of global types.
It is, however, still convenient to write a global type and have local types computed programatically. Global types are defined as follows: 

TABLE 3

Global actions denoted by \pi describe the interactions between participants: p $\rightarrow$ q : l(A) states that role p sends a message with label l and payload type A to q . Similarly, p \twoheadrightarrow q : l(A) denotes a connection action from p to q by sending a message with label l and payload type A. The disconnection action p \# q states that role p disconnects from role q.
STORE EXAMPLE
Although projectability in our situation does not ensure safety or deadlock-freeness, the safety of the generated local types can be checked to guarantee safety [2].


Protocols
A protocol is a set of mappings from role names to local session types. It is of the format {p_i : S_i}
STORE EXAMPLE
In the context of a program, ty(p) refers to the session type associated with the particular role as defined by the set of protcols.


Session Type Aliases
Session type alias create a new name to refer a session type. An identifier defined for a session type can then be used as required in the program to refer the session type.


Program
A Mini-EnsembleS program consists of a set of session type aliases, actor definitions, protocols and an initial computation term in the 'boot' clause to be evaluated in order to set up initial actor communications. Thus, a program P can be defined as the collection of (TA, D, P, M).


TYPING RULES
Tables _ _ show typing rules for Mini-EnsembleS [2].
Value typing, with judgement $\Gamma \vdash V:A$ states that under typing environment \Gamma, the value V has type A (T-VAR). Typing of unit value gives unit type (T-UNIT). Similarly, typing of any of the base value - string, int, bool gives the respective type STRING (T-STRING), INT (T-INT), BOOL (T-BOOL).
T-DEF: Definition typing, with judgement $\vdash D$ states that an actor definition actor u follows S {M} is well-typed if its body M is typable under S and fully consumes its statically defined session type S i.e. the actor behaviour follows and consumes the actions defined in the session type.
The behaviour typing judgement ${S} \Gamma \vdash \kappa$ states the behaviour $\kappa$ is well-typed under $\Gamma$ for a given session type S. In this case, stop is always well-typed (T-STOP), and M is well-typed if it is typable under and fully consumes S (T-BODY).


TYPING RULES FOR COMPUTATION
Term typing judgement ${T} \Gamma \vdash S \triangleright M : A \triangleleft S′$ states that in an actor following a session type T, under the typing environment $\Gamma$ and with the current session type S, term M has the type A and updates the current session type to S′. Here, S is the session precondition and the term M may perform some session communication action to update the session type to postcondition S′.

FUNCTIONAL RULES
Rule T-LET : Given the construct let x <= M in N, where M, under typing environment $\Gamma$, has pre-condition S and produces type A with post-condition S′, and where N, under the extended typing environment $\Gamma, x:A$, has pre-condition S′ and returns type B with post-condition S′′, the construct has an overall pre-condition S and postcondition S′′ with type B. This rule works like a sequencing operation.
Rule T-RETURN states that type checking the construct return V, with pre-condition S, yields the type value of V under typing environment $\Gamma$ i.e. A and post-condition S (no change in current session type)
Rule T-REC : Given the construct l :: M, rule states that term M, an expression which can loop to l, when evaluated using the extended typing environment $\Gamma, l : S$ gives post condition S′ and type A. Recursive session types can also be identified with their unfolding $(\mu X.S = S{\mu X.S/X})$ i.e. equi-recursive view of session types under the assumption that the recursion is guarded. For instance, this implies that $\mu X . Pinger ! ping(String) . X$ is equivalent to $Pinger ! ping . \mu X . Pinger ! ping(String) . X$.
Rule T-CONTINUE : This rule ensures that for the construct continue l, the pre-condition typing environment $\Gamma$ must contain the matching label l. Since the behaviour recurses back to the defined label l, the rule produces an arbitrary type and any post-condition dependent on the base case of the enclosing loop.

Γ \vdash V:Bool
{T} Γ | S ▷ M :A ◁ S′
{T} Γ | S ▷ N :A ◁ S′
{T} Γ | S ▷ if V then M else N : A ◁ S′

Rule T-CONDITION : Given the construct if V then M else N, where type of V is a bool, M with pre-condition S, gives type A and post-condition S′, and N with pre-condition S give the same type A and post-condition S′, the overall construct has a pre-condition S and post-condition S′ with type A. This rule provides with a conditional statement.


ACTOR ADAPTION RULES
These rules do not update the current session type and thus, have the same pre-condition S and post-condition S′.
Rule T-NEW : Rule states that spawning an actor of class u returns the PID of the session type declared in the class of u. 
Rule T-SELF : Rule retrieves the PID for the current actor, parameterised by the statically-defined session type which the local actor follows. (i.e., the T in the judgement {T} Γ | S ▷ M :A ◁ S′).
Rule T-DISCOVER : Given the term discover U, the construct returns a PID of type Pid(U).
Rule T-REPLACE : Rule allows replacement of an actor with PID of session type U (actor follows session type U) with a behaviour \kappa, typable under the static session type U, and returns the unit type.


EXCEPTION HANDLING
Rule T-RAISE denotes raising an exception. It does not return and hence, has an arbitrary return type and post-condition.
Rule T-TRY types an exception handler try L catch M. The single action L is evaluated and if it raises an exception, then M is evaluated instead. The try and catch clauses must have the same pre-condition and post-condition to allow the action to be retried if necessary. Hence, type checking action L and M return the same type A and post-condition S′.

SESSION COMMUNICATION ACTIONS
Rule T-CONN: The rule types a term connect \ell_j(V) to W as p_j. The pre-condtition in this case, must be a choice type containing a branch p!!l_j(A_j).S_j′. The label and payload in the construct must be compatible with the appropriate branch and value type of payload V must match type A_j in the branch. The remote actor to be connected in this session action must have reference in W i.e. W is of type Pid(T′) where T′ is compatible with the type of role p_j. After this, the current session type S is changed to the matching branch's continuation S_j′ and unit type is returned. The similar procedure is followed by Rule T-SEND.
Rule T-ACCEPT: Given the current session type contains accept action(s) i.e. $\sum_{i\in I}(q??x_i(A_i)).S_i$, the rule types the term accept from p {$\ell_i$(x_i) $\mapsto$ M_i}_{i\in I} allowing an actor to accept connections from role p with messages $\ell_i$, binding the payload x_i in each continuation M_i. Each of these computation terms must be typable under the the typing environment \Gamma extended with x_i : A_i, under respective session type S_i. Also, each of these branches must have the same result type A and post-condition S. Rule T-RECV is similar.
Rule T-WAIT: Rule handles the construct wait p where an actor is waiting for a participant p to disconnect from a session, requiring the pre-condition session type of \#p . S, returning the unit type and advancing the session type to S.
Rule T-DISCONNECT: Rule handles disconnection action from a participant p, requiring disconnection session  type as pre-condition i.e. \#\#p. It returns the unit type and advances the session type to end for termination.