Technology is evolving at an accelerating pace, creating a new, stronger generation of technologies. Computing platforms have evolved from isolated computers to heterogeneous hardware devices, consisting of multicore CPUs and co-processors, to embedded IoT devices and self-driving cars. Due to the wide diversity of resource limitations and operating conditions connected with these platforms, applications must be able to adapt to their execution environment to make the greatest use of the resources available. Applications must be able to successfully operate in different environments, identify resources, and efficiently communicate with other technologies. Communication in these distributed systems is becoming one of the central elements in the software development of these technologies [7]. This is especially challenging as different classes of hardware devices each use their programming styles and runtimes, requiring developers to have knowledge of different programming styles, hardware platforms, and networking protocols [1].

Dynamic self-adaptation is a systems concept that allows devices to discover, connect and communicate with other software components at run-time. Instead of modifying entire applications, adaptation provides software components with the ability to discover and communicate with other components which were not part of the original system design [2]. Communication protocols in distributed systems are quite complex; the order of communication and the type of data exchanged is dictated by these protocols. Most mainstream programming languages do not support mechanisms to ensure that dynamic adaptation can be achieved safely or result in rather prohibitive runtime overheads.

In the actor model of adaptation, actors have shared-nothing semantics i.e. they share no state and interact using explicit message passing. This model provides the ideal structure to facilitate runtime adaptation [1]. Ensemble is an imperative actor-based language that has native support for adaptation. An Ensemble actor has its own private state and a single thread of control expressed as a behaviour clause. Ensemble actors share no state amongst one another. They interact via explicit message passing awith long uni-directional, typed channels. Ensemble applications are compiled in Java source code and can be executed on desktops and various hardware platforms. Using Ensemble enables the spawning, migration and runtime discovery of actors which communicate via its channels across supported platforms. However, using Ensemble for runtime-adaptation lead to concurrency errors, deadlocks amongst actors and communication mismatches and hence, cannot guarantee safety. Multiparty session types can be used to address this problem.

Session types have been researched in detail as a potential typed foundation for structured communication-centred programming [7]. Communication-based applications frequently display a highly ordered sequence of interactions that, when taken together, make a natural session unit. A session's structure is abstracted as a type using a simple syntax, which is then used to validate applications through an associated type discipline [3]. Session types thus provide a typing discipline by assigning session types to communication channels, in terms of the sequence of interactions that take place over a channel.

As a simple example, the following session type describes a communication protocol between a Customer and an Agency from the Customer's perspective.
In this protocol, the Customer sends the selected travel location (a string), the Agency sends a price quote for that location (an integer). The customer makes a decision/choice at this point, to either accept or reject the offer. If not satisfied, the communication ends immediately; If satisfied by the quote, the Customer sends his address (a string) and the Agency sends the confirmed dates of travel (a date) and the protocol terminates;

! string . ? int . (! string . ? date . end) + (end)

These explicit communication actions help deal with synchronisation among actors. A programmer expects communication programmes to carry on a consistent conversation, but they frequently fail to handle a specific incoming message or deliver a message at the correct time, with no method to identify such errors before runtime. Explicit representation of communication actions, such as above, drives principled communication behaviour development [3] and allows for automatic validation of these protocols through the exchange of messages.


Session types, initially only able to describe communications between two ends of a channel, are later extended to multiparty [7], giving rise to the multiparty session types (MPST) theory. MPST generalise the binary session type theory to the multiparty case, ensuring that protocols, involving two or more participants, are free from communication errors and deadlocks if the processes are well-typed [4]. The core idea of the formalism is to specify the type, direction and sequence of communication actions by introducing global types. Global types describe the conversations from a global perspective and provide a tool to check protocol agreement.
The approach is as follows:
1. Construct a global type that provides a shared contract for the systems' acceptable message exchange pattern.
2. Project the global type to each participating actor to get a local type, which describes the protocol from the local point of view.
3. Check that each process' implementation adheres to its local type.
These local types are used to validate an application through type-checking. The local conformance of each participant guarantees global conformance of the network [3].


EnsembleS is an actor-based language that integrates the concepts of MPSTs to provide compile-time verification of safe adaptation. It integrates the notions of explicit connection actions and type-checking of MPST to the actor paradigm, which allows to statically guarantee that a discovered actor will follow the communication protocol and that changing the actor's behaviour will not threaten the communication safety. The core calculus of EnsembleS proves that the integration of adaptation with multiparty session types is safe. EnsembleS is implemented directly on top of Ensemble, which introduces various implementation artefacts and obscures the core language's fundamental concepts. The calculus of EnsembleS is minimal and can be implemented using a much smaller core language. This project aims to implement a typechecker for a small, clean core language based on this calculus, which conveys the core ideas better. The project includes the design of a concrete syntax and implements a parser into an abstract syntax tree. The implementation is evaluated by applying it to different case studies such as a Ping-Pong scheme, a Bookstore example, and an adaptive DNS server. This model provides a more flexible and extensible tool for future extensions and experiments.