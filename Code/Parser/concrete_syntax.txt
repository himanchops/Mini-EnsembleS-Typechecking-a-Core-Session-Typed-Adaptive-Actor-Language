####CONCRETE SYNTAX

EXAMPLE:
actor PingerActor follows (Ponger !! ping(unit) . Ponger ? pong(unit) . #Ponger . end) {
    let pid <= discover Ponger in
    connect ping(()) to pid as Ponger;
    receive from Ponger {
        pong(x) -> wait Ponger
    }
}

actor PongerActor follows (Pinger ?? ping(unit) . Pinger ! pong(unit) . ##Ponger) {
    accept from Pinger {
        case ping(()) ->
            send pong(()) to Pinger;
            disconnect from Pinger
    }
}


#TYPE
Pid(<sessionType>) | TString | TInt | TBool | Unit

#ACTOR DEFINITION
actor <actorName> follows (<sessionType>) {<computation>}

#ACTIONS
return <value>
continue <label>
raise
new <actorName>
self
replace <value> with <behaviour>
discover <sessionType>
connect <label>(<value>) to <value> as <role>
send <label>(<value>) to <role>
receive from <role> { case <label>(<value>) -> <computation> .. }
receive <label><value> from <role>; <computation>
accept from <role> { case <label>(<value>) -> <computation> .. }
accept <label><value> from <role>; <computation>
wait <role>
disconnect from <role>
if <action> then <computation> else <computation>
<value> == <value>
<value> /= <value>


#COMPUTATION
let <binder> <= <compuation> in <compuation>
comp1; comp2
try <action> catch <compuation>
<label> :: <computation>
<action>


#SESSION ACTIONS
<role> ! <label>(<type>)
<role> !! <label>(<type>)
<role> ? <label>(<type>)
<role> ?? <label>(<type>)
#<role>						//wait for disconnection

#SESSION TYPE
(<sessionAction>. <SessionType>)
rec X.S
X
##<role>							//disconnect
end
<sessionTypeName>


#TYPE IDENTIFIER
type <SessionTypeName> = <SessionType>

#Protocol
<role> : <sessionType>


Main :: Parser Program
Program = ([TypeAlias], [D], M)

SessionTypeName vs X